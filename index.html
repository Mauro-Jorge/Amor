<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Lays ❤️ Mauro - Nosso Amor Infinito</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(to right, #ffe6eb, #fcddec);
      color: #e6005c;
      text-align: center;
      margin: 0;
      padding: 2rem;
      overflow-x: hidden;
    }
    h1 {
      font-size: 2.5rem;
      color: #d63384;
      margin-bottom: 1.5rem;
    }
    .pulsing-heart {
      animation: pulse 1.5s ease-in-out infinite;
      display: inline-block;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.25); }
      100% { transform: scale(1); }
    }
    h2, h3 {
      font-size: 2rem;
      color: #d63384;
      margin-top: 2.5rem;
      margin-bottom: 1rem;
    }
    canvas {
      max-width: 700px;
      margin: 2rem auto;
      background: white;
      border-radius: 20px;
      box-shadow: 0 10px 20px rgba(0,0,0,0.1);
    }
    #rouletteCanvas {
        border-radius: 50%;
        box-shadow: 0 0 15px rgba(0,0,0,0.2);
    }
    .music-player-container {
      margin-top: 2rem;
      margin-bottom: 2rem;
      padding: 10px;
      border-radius: 10px;
      display: inline-block;
      background-color: rgba(255, 255, 255, 0.7);
      box-shadow: 0 6px 12px rgba(0,0,0,0.1);
    }
    .music-player-container audio {
      width: 300px;
    }
    .interactive-section, .countdown-container, .daily-phrase-container, .quadrinho-amor-container, .game-container {
      background-color: rgba(255, 255, 255, 0.8);
      padding: 20px;
      border-radius: 15px;
      margin: 2rem auto;
      max-width: 600px;
      box-shadow: 0 8px 16px rgba(0,0,0,0.1);
      min-height: 100px;
    }
    #countdownTimer {
      font-size: 1.8em;
      font-weight: bold;
      color: #d63384;
    }
    #dailyPhrase {
      font-size: 1.3em;
      font-style: italic;
      color: #c2185b;
      margin-top: 0.5em;
    }
    .container-title {
        font-size: 1.8em;
        color: #e6005c;
        margin-bottom: 1em;
    }

    /* Estilos para o Mosaico de Imagens */
    .image-mosaic-container { margin: 2.5rem auto; padding: 15px; background-color: rgba(255, 255, 255, 0.75); border-radius: 15px; box-shadow: 0 10px 20px rgba(0,0,0,0.1); max-width: 900px; }
    .image-mosaic { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); grid-auto-rows: minmax(200px, auto); gap: 15px; }
    .image-mosaic .mosaic-item { width: 100%; aspect-ratio: 1 / 1; overflow: hidden; border-radius: 10px; box-shadow: 0 6px 12px rgba(0,0,0,0.15); }
    .image-mosaic .mosaic-item img { width: 100%; height: 100%; object-fit: cover; display: block; transition: transform 0.3s ease, filter 0.3s ease; }
    .image-mosaic .mosaic-item img:hover { transform: scale(1.08); filter: brightness(1.1); }
    .mosaic-item.featured { grid-column: span 2; grid-row: span 2; aspect-ratio: 1 / 1; }

    /* Estilos para Quadrinhos do Amor */
    .quadrinho-imagem img { max-width: 100%; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); margin-top: 10px; margin-bottom: 15px; }
    .quadrinho-descricao { font-size: 0.95em; text-align: left; line-height: 1.5; }
    .quadrinho-descricao h4 { color: #c2185b; font-size: 1.2em; margin-top: 15px; margin-bottom: 8px; font-weight: bold; }
    .quadrinho-descricao p { margin-bottom: 12px; color: #5c3a0a; }
    .quadrinho-descricao p.official-desc { font-style: italic; color: #75542B; background-color: rgba(255, 240, 245, 0.5); padding: 10px; border-radius: 5px; }
    .quadrinho-descricao p.cute-message strong { color: #d63384; }

    /* Estilos para Animação do Envelope (sem alterações) */
    /* ... (Estilos do envelope omitidos para brevidade, mas estão no código completo anterior) ... */
    .envelope-container { position: relative; width: 320px; height: 220px; margin: 20px auto; }
    .envelope { position: absolute; width: 100%; height: 100%; background-color: #ffc0cb; border-radius: 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); display: flex; align-items: center; justify-content: center; }
    .envelope-flap { position: absolute; top: 0; left: 0; width: 100%; height: 55%; background-color: #ffb6c1; clip-path: polygon(0 0, 100% 0, 100% 30%, 50% 100%, 0 30%); transform-origin: top; transition: transform 0.7s ease-in-out; z-index: 3; }
    .envelope-container.open .envelope-flap { transform: rotateX(180deg); }
    .letter { position: absolute; width: 90%; height: 85%; background-color: #fffaf0; border: 1px solid #f0e68c; border-radius: 8px; padding: 15px; box-sizing: border-box; text-align: left; font-family: 'Courier New', Courier, monospace; font-size: 0.8rem; line-height: 1.4; color: #5c3a0a; overflow-y: auto; z-index: 1; transform: translateY(100%); opacity: 0; transition: transform 0.7s 0.5s ease-out, opacity 0.7s 0.5s ease-out; }
    .envelope-container.open .letter { transform: translateY(-5%); opacity: 1; z-index: 2; }
    .letter-content h4 { text-align: center; color: #d63384; margin-bottom: 10px; }
    .letter-content p { margin-bottom: 10px; }
    .letter-content .signature { text-align: right; margin-top: 15px; font-style: italic; }
    .letter-content .ps { margin-top: 15px; font-size: 0.9em; }


    /* Estilos para Quiz do Casal */
    .quiz-container { text-align: left; }
    .quiz-question { margin-bottom: 15px; font-weight: bold; }
    .quiz-options label { display: block; margin-bottom: 8px; cursor: pointer; }
    .quiz-options input { margin-right: 8px; }
    .quiz-button { background-color: #d63384; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 1em; margin-top: 15px; }
    .quiz-button:hover { background-color: #c2185b; }
    .quiz-score, .love-thermometer-display { margin-top: 20px; font-size: 1.2em; }
    .love-thermometer-bar-container { width: 100%; background-color: #fddde6; border-radius: 10px; height: 30px; margin-top: 10px; overflow: hidden; border: 1px solid #d63384; }
    .love-thermometer-bar { width: 0%; height: 100%; background-color: #e6005c; border-radius: 8px; transition: width 0.5s ease-in-out; text-align: center; line-height: 30px; color: white; }
    .player-turn { font-weight: bold; color: #e6005c; margin-bottom: 10px; }

    /* Estilos para Roleta do Amor */
    .roulette-container { display: flex; flex-direction: column; align-items: center; }
    .spin-button { margin-top: 20px; padding: 12px 25px; font-size: 1.2em; background-color: #d63384; color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.3s; }
    .spin-button:hover { background-color: #c2185b; }
    #rouletteResult { margin-top: 15px; font-size: 1.3em; font-weight: bold; color: #e6005c; }

    /* --- ESTILOS PARA OS JOGOS ANTERIORES (VELHA E CAÇA-PALAVRAS) --- */
    .game-status { margin-top: 15px; font-size: 1.2em; font-weight: bold; }
    #tic-tac-toe-board { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); width: 240px; height: 240px; margin: 20px auto; border: 2px solid #d63384; border-radius: 10px; }
    .ttt-cell { display: flex; justify-content: center; align-items: center; font-size: 3em; font-weight: bold; border: 1px solid #f48fb1; cursor: pointer; user-select: none; }
    .ttt-cell:hover { background-color: #ffe6eb; }
    .ttt-cell.heart { color: #e91e63; }
    .ttt-cell.x { color: #3f51b5; }
    #word-search-grid-container { display: grid; border: 2px solid #d63384; margin: 15px auto; padding: 5px; background-color: #fff0f5; max-width: 400px; }
    .ws-cell { width: 30px; height: 30px; display: flex; justify-content: center; align-items: center; border: 1px solid #f8bbd0; font-family: 'Courier New', Courier, monospace; font-size: 1.1em; font-weight: bold; text-transform: uppercase; cursor: pointer; user-select: none; }
    .ws-cell.selected { background-color: #ffc0cb; color: #c2185b; }
    .ws-cell.found { background-color: #a5d6a7; color: #2e7d32; animation: foundPulse 0.5s ease-out; }
    @keyframes foundPulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    #word-search-list-container { margin-top: 15px; text-align: left; }
    #word-search-list li { list-style: none; font-size: 1.1em; color: #5c3a0a; margin-bottom: 5px; }
    #word-search-list li.found-in-list { text-decoration: line-through; color: #9e9e9e; }
    #word-search-prize-container { margin-top: 20px; padding: 15px; background-color: #fff9c4; border: 2px dashed #ffb300; border-radius: 10px; }
    #prize-won { color: #e65100; }

    /* --- NOVOS ESTILOS PARA O QUEBRA-CABEÇA --- */
    #puzzle-board-container {
        display: grid;
        /* grid-template-columns será definido por JS */
        width: 300px; /* Ajuste para o tamanho desejado do quebra-cabeça */
        height: 300px; /* Deve ser proporcional à imagem original */
        border: 3px solid #d63384;
        margin: 20px auto;
        position: relative; /* Para posicionamento de peças se necessário */
        background-color: #fde4ec; /* Um fundo suave */
        border-radius: 10px;
    }
    .puzzle-piece {
        /* width e height serão definidos por JS */
        border: 1px solid #ff80ab; /* Borda rosa mais forte para as peças */
        background-size: 300px 300px; /* Deve corresponder ao tamanho do #puzzle-board-container */
        background-repeat: no-repeat;
        cursor: grab;
        transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
        box-sizing: border-box; /* Para incluir a borda no tamanho */
    }
    .puzzle-piece.dragging {
        opacity: 0.7;
        cursor: grabbing;
        box-shadow: 0 0 15px rgba(214, 51, 132, 0.7);
        transform: scale(1.05);
    }
    .puzzle-piece.over {
        border: 2px dashed #c2185b; /* Destaque ao passar por cima de um alvo de drop */
    }
    #puzzle-message {
        font-weight: bold;
        margin-top: 15px;
    }

  </style>
</head>
<body>
  <h1>Lays <span class="pulsing-heart">❤️</span> Mauro</h1>

  <div class="image-mosaic-container">
    <h3>Nossos Momentos ❤️</h3>
    <div class="image-mosaic">
      <div class="mosaic-item featured"><img src="img2.jpeg" alt="Lays e Mauro - Momento 2 (Destaque)"></div>
      <div class="mosaic-item"><img src="img1.jpeg" alt="Lays e Mauro - Momento 1"></div>
      <div class="mosaic-item"><img src="img3.jpeg" alt="Lays e Mauro - Ilustração Especial"></div>
      <div class="mosaic-item"><img src="img4.jpeg" alt="Lays e Mauro - Momento 4"></div>
      <div class="mosaic-item"><img src="img5.jpeg" alt="Lays e Mauro - Momento 5"></div>
    </div>
  </div>

  <div class="quadrinho-amor-container">
    <h3 class="container-title">Cena 1: Cuidado Delicado 💪🩹😅</h3>
    <div class="quadrinho-imagem"> <img src="cena1.png" alt="Mauro cuidando do dedo de Lays - Quadrinho do Amor"> </div>
    <div class="quadrinho-descricao"><h4>Nossa História na Cena:</h4><p class="official-desc">O tatame tinha sido palco de mais um treino intenso para Lays, e entre um movimento e outro, um pequeno arranhão no dedo surgiu como um lembrete da sua dedicação...</p><h4>Nossos Pensamentos na Cena:</h4><p class="cute-message"><strong>Mauro (💪🩹😅):</strong> "Missão curativo: quase tão complexa quanto debugar um código às 3 da manhã! Mas por ela, viro até enfermeiro!"</p><p class="cute-message"><strong>Lays (😊💖🥋):</strong> "Meu gigante gentil! Adoro esse jeitinho protetor e levemente desajeitado dele. Cada cuidado é uma declaração."</p></div>
  </div>

  <div class="quadrinho-amor-container">
    <h3 class="container-title">Cena 2: Chef Apaixonado 👨‍🍳🔥👖</h3>
    <div class="quadrinho-imagem"> <img src="cena2.png" alt="Mauro cozinhando para Lays - Quadrinho do Amor"> </div>
    <div class="quadrinho-descricao"><h4>Nossa História na Cena:</h4><p class="official-desc">O aroma que escapava da cozinha era uma sinfonia de temperos que prometia mais uma noite especial. Mauro, com seu sorriso que iluminava mais que qualquer fogo alto, comandava as panelas como um maestro apaixonado...</p><h4>Nossos Pensamentos na Cena:</h4><p class="cute-message"><strong>Mauro (👨‍🍳🔥👖):</strong> "Ingrediente secreto de hoje: uma pitada extra de 'quero te ver feliz' em cada panela! O sorriso dela no final é meu melhor prêmio."</p><p class="cute-message"><strong>Lays (🥰🍽️🛋️):</strong> "A sinfonia de aromas já me conquistou! E ver a paixão dele cozinhando... Ah, isso alimenta a alma e o coração. Pronta para ser mimada!"</p></div>
  </div>

  <h3>Uma música especial para nós:</h3>
  <div class="music-player-container"> <audio id="local-audio-player" controls src="true_love_soja.mp3">Seu navegador não suporta o elemento de áudio.</audio> </div>

  <div class="countdown-container">
    <p class="container-title" id="countdownTitle">Contagem regressiva para nossos 3 meses! 🥂✨</p>
    <div id="countdownTimer">Carregando...</div>
  </div>

  <div class="daily-phrase-container">
    <p class="container-title">Pensamento do Dia 🥰:</p>
    <div id="dailyPhrase">Carregando frase...</div>
  </div>

  <div class="interactive-section game-container" id="jogo-da-velha-secao">
    <h2 class="container-title">Jogo da Velha do Amor 💖<span style="font-size: 0.7em; color: #6a1b9a;"> X </span>💙</h2>
    <div id="tic-tac-toe-board">
      <div class="ttt-cell" data-index="0"></div> <div class="ttt-cell" data-index="1"></div> <div class="ttt-cell" data-index="2"></div>
      <div class="ttt-cell" data-index="3"></div> <div class="ttt-cell" data-index="4"></div> <div class="ttt-cell" data-index="5"></div>
      <div class="ttt-cell" data-index="6"></div> <div class="ttt-cell" data-index="7"></div> <div class="ttt-cell" data-index="8"></div>
    </div>
    <p id="tic-tac-toe-status" class="game-status">Vez do ❤️ (Lays)</p>
    <button id="restart-tic-tac-toe" class="quiz-button">Jogar Novamente</button>
  </div>

  <div class="interactive-section game-container" id="caca-palavras-secao">
    <h2 class="container-title">Caça Palavras do Amor 💘</h2>
    <p>Lays, encontre as palavras de amor e ganhe um delicioso Vale Doces!</p>
    <div id="word-search-grid-container"></div>
    <div id="word-search-list-container"> <h3 style="color: #c2185b;">Palavras para Encontrar:</h3> <ul id="word-search-list"></ul> </div>
    <div id="word-search-feedback" style="margin-top:10px; font-weight:bold;"></div>
    <div id="word-search-found-container" style="margin-top:10px;"> <h3 style="color: #c2185b;">Palavras Encontradas: <span id="found-count">0</span> de <span id="total-words-display">0</span></h3> </div>
    <div id="word-search-prize-container" style="display:none;"> <h3 style="color: #d63384;">Parabéns Lays! 🎉 Seu Vale Doces é:</h3> <p id="prize-won" style="font-size: 1.8em; font-weight: bold; color: #e65100;"></p> </div>
    <button id="reset-word-search" class="quiz-button" style="margin-top:15px;">Novo Jogo / Misturar</button>
  </div>

  <div class="interactive-section game-container" id="quebra-cabeca-secao">
    <h2 class="container-title">Quebra-Cabeça do Nosso Amor 🧩</h2>
    <p>Juntem as peças e revelem uma linda imagem de vocês!</p>
    <div id="puzzle-board-container">
      </div>
    <div id="puzzle-controls" style="margin-top: 15px;">
      <button id="start-puzzle-button" class="quiz-button">Embaralhar e Começar</button>
      <p id="puzzle-message" class="game-status" style="margin-top: 10px;"></p>
    </div>
  </div>


  <h2>Nossa Jornada de Amor</h2>
  <p id="loveJourneyDescription">Gráfico do crescimento do nosso amor...</p>
  <canvas id="heartChart" width="400" height="400"></canvas>

  <div class="interactive-section">
    <h2>Quiz Surpresa do Casal! 💑</h2>
    <div class="quiz-container">
      <div id="playerIndicator" class="player-turn"></div> <div id="quizQuestion" class="quiz-question"></div> <div id="quizOptions" class="quiz-options"></div>
      <button id="nextQuizButton" class="quiz-button">Carregando Quiz...</button> <div id="quizScore" class="quiz-score"></div>
      <div class="love-thermometer-display"> 🌡️ Termômetro do Amor (Sintonia): <div class="love-thermometer-bar-container"> <div id="loveThermometerBar" class="love-thermometer-bar">0%</div> </div> </div>
    </div>
  </div>

  <h2>Nosso Amor em Um Só Coração ❤️</h2>
  <canvas id="perfectHeartShapeChart" width="400" height="400"></canvas>

  <div class="interactive-section">
    <h2>Roleta do Amor 🎡💕</h2>
    <div class="roulette-container">
        <canvas id="rouletteCanvas" width="450" height="450"></canvas>
        <button id="spinRouletteButton" class="spin-button">Girar a Roleta!</button>
        <div id="rouletteResult">Clique para sortear!</div>
    </div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // --- DATA DE INÍCIO DO RELACIONAMENTO E OUTRAS CONFIGS GLOBAIS ---
    const relationshipStartDate = new Date("March 5, 2025 00:00:00");

    // --- Cronômetro Regressivo ---
    try {
        const anniversaryDate = new Date("June 5, 2025 00:00:00").getTime();
        const countdownTitleEl = document.getElementById('countdownTitle');
        const countdownElement = document.getElementById("countdownTimer");

        if (countdownTitleEl && countdownElement) {
            const countdownInterval = setInterval(function() {
                const now = new Date().getTime();
                const distance = anniversaryDate - now;
                if (distance < 0) { /* ... (lógica do envelope) ... */
                    clearInterval(countdownInterval);
                    countdownElement.innerHTML = "";
                    countdownTitleEl.innerHTML = "Chegou o nosso dia especial! ❤️";
                    const envelopeContainerDiv = document.createElement('div'); envelopeContainerDiv.className = 'envelope-container'; const envelopeDiv = document.createElement('div'); envelopeDiv.className = 'envelope'; const flapDiv = document.createElement('div'); flapDiv.className = 'envelope-flap'; const letterDiv = document.createElement('div'); letterDiv.className = 'letter'; letterDiv.innerHTML = `<div class="letter-content"><h4>🌽💛 Bilhetim Arretado d’amô 💛🌽</h4><p>Pra minha cabocla mais linda, Lays</p><p>Hoje é 5 de junho, meu amor, e a gente tá comemorando 3 meses de namoro...<br>Mas tu sabe, né? Esse amô começou muito antes disso.<br>Antes de ser minha namorada, tu já era minha melhor amiga,<br>meu alicerce, meu riso fácil, meu abraço certo. 🌾</p><p>Tu chegou feito bandeirinha de São João no céu da roça,<br>trazendo cor, calor de fogueira boa,<br>e o aconchego de rede em fim de tarde.<br>Ô sorte grande que foi te encontrar! 🔥</p><p>Tu é arretada, Lays. Uma mulher daquelas que a gente admira em silêncio,<br>e ama em voz alta.<br>Forte, inteligente, linda…<br>Teu jeito me encanta e tua presença me acalma.<br>O amor que sinto é tão grande que nem zabumba e sanfona dão conta de tocar!</p><p>Hoje, tudo que eu queria era um forrozim colado contigo,<br>debaixo das estrelas, te sussurrando baixinho:<br>“Oxente, como é bão te amar, viu?” 💃🕺</p><p class="signature">Obrigado por me fazer tão feliz.<br>Tu é meu xodó, minha fogueirinha que nunca se apaga. ❤️‍🔥</p><p class="signature">Com todo meu carinho e paixão,<br>do teu matuto apaixonado,<br>Mauro 💘</p><p class="ps">P.S.: Vamo simbora viver muitos São Joãos juntos? 💍👒🎉</p></div>`; envelopeDiv.appendChild(flapDiv); envelopeDiv.appendChild(letterDiv); envelopeContainerDiv.appendChild(envelopeDiv); countdownElement.appendChild(envelopeContainerDiv); setTimeout(() => { envelopeContainerDiv.classList.add('open'); }, 500);
                } else { const days = Math.floor(distance / (1000 * 60 * 60 * 24)); const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)); const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60)); const seconds = Math.floor((distance % (1000 * 60)) / 1000); countdownElement.innerHTML = `${days}d ${hours}h ${minutes}m ${seconds}s ⏳`; }
            }, 1000);
        } else { console.error("Elementos do cronômetro não encontrados."); }
    } catch (e) { console.error("Erro no cronômetro:", e); }

    // --- Frases Românticas Diárias ---
    try {
        const romanticPhrases = ["Cada dia ao seu lado é um novo capítulo da nossa linda história de amor! Te amo! ❤️","Você é a melodia que meu coração não cansa de tocar e dançar. 🎶💑","Nosso amor floresce mais forte e belo a cada amanhecer juntos. 🌹☀️","Contando os segundos para sentir seu abraço e me perder no seu olhar! 🤗💖","Com você, a vida é uma eterna primavera, cheia de cores e alegrias. Te amo, meu bem! 🌷💞","Seu sorriso ilumina meus dias e aquece minha alma como o sol da manhã. 😊💘","Para sempre ainda parece pouco tempo para todo o amor que sinto por você. Te amo infinitamente! 💫💌","Que sorte a minha ter encontrado em você meu porto seguro e minha maior aventura! ⛵🗺️","Nossos corações batem no mesmo ritmo, construindo a mais linda canção de amor. 💞🎼","Você transforma o ordinário em extraordinário só por existir na minha vida. ✨ Te amo!"];
        const today = new Date(); const dayOfYear = Math.floor((today - new Date(today.getFullYear(), 0, 0)) / (1000 * 60 * 60 * 24)); const phraseIndex = dayOfYear % romanticPhrases.length; const dailyPhraseElement = document.getElementById("dailyPhrase");
        if (dailyPhraseElement) { dailyPhraseElement.innerHTML = `"${romanticPhrases[phraseIndex]}"`; } else { console.error("Elemento da frase diária não encontrado."); }
    } catch (e) { console.error("Erro na frase diária:", e); }

    // --- LÓGICA PARA O JOGO DA VELHA DO AMOR ---
    try { /* ... (Código Jogo da Velha como na resposta anterior) ... */
        const ttt_boardElement = document.getElementById('tic-tac-toe-board'); const ttt_statusElement = document.getElementById('tic-tac-toe-status'); const ttt_restartButton = document.getElementById('restart-tic-tac-toe'); const ttt_cells = Array.from(document.querySelectorAll('.ttt-cell'));
        if (ttt_boardElement && ttt_statusElement && ttt_restartButton && ttt_cells.length === 9) {
            let ttt_currentPlayerSymbol = '❤️'; let ttt_boardState = Array(9).fill(null); let ttt_gameActive = true; const ttt_winningConditions = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
            function ttt_handleCellClick(event) { const clickedCell = event.target; const clickedCellIndex = parseInt(clickedCell.getAttribute('data-index')); if (ttt_boardState[clickedCellIndex] !== null || !ttt_gameActive) return; ttt_boardState[clickedCellIndex] = ttt_currentPlayerSymbol; clickedCell.textContent = ttt_currentPlayerSymbol; clickedCell.classList.add(ttt_currentPlayerSymbol === '❤️' ? 'heart' : 'x'); if (ttt_checkWin()) { ttt_statusElement.textContent = `🎉 Jogador ${ttt_currentPlayerSymbol} Venceu! 🎉`; ttt_gameActive = false; return; } if (ttt_boardState.every(cell => cell !== null)) { ttt_statusElement.textContent = "Ops! Deu Velha! Empate! 💔"; ttt_gameActive = false; return; } ttt_currentPlayerSymbol = ttt_currentPlayerSymbol === '❤️' ? 'X' : '❤️'; let nextPlayerName = ttt_currentPlayerSymbol === '❤️' ? "Lays (❤️)" : "Mauro (X)"; ttt_statusElement.textContent = `Vez do jogador ${nextPlayerName}`; }
            function ttt_checkWin() { for (const condition of ttt_winningConditions) { const [a,b,c] = condition.map(index => ttt_boardState[index]); if (a && a === b && b === c) return true; } return false; }
            function ttt_restartGame() { ttt_currentPlayerSymbol = '❤️'; ttt_boardState.fill(null); ttt_gameActive = true; ttt_statusElement.textContent = `Vez do ❤️ (Lays)`; ttt_cells.forEach(cell => { cell.textContent = ''; cell.classList.remove('heart', 'x'); }); }
            ttt_cells.forEach(cell => cell.addEventListener('click', ttt_handleCellClick)); ttt_restartButton.addEventListener('click', ttt_restartGame);
        } else { console.error("Elementos do Jogo da Velha não encontrados ou incompletos."); }
    } catch (e) { console.error("Erro no Jogo da Velha:", e); }

    // --- LÓGICA PARA O CAÇA PALAVRAS DO AMOR ---
    try { /* ... (Código Caça Palavras como na resposta anterior) ... */
        const ws_gridContainer = document.getElementById('word-search-grid-container'); const ws_wordListElement = document.getElementById('word-search-list'); const ws_foundCountElement = document.getElementById('found-count'); const ws_totalWordsElement = document.getElementById('total-words-display'); const ws_prizeContainerElement = document.getElementById('word-search-prize-container'); const ws_prizeWonElement = document.getElementById('prize-won'); const ws_resetButton = document.getElementById('reset-word-search'); const ws_feedbackElement = document.getElementById('word-search-feedback');
        if (ws_gridContainer && ws_wordListElement && ws_foundCountElement && ws_totalWordsElement && ws_prizeContainerElement && ws_prizeWonElement && ws_resetButton && ws_feedbackElement) {
            const ws_wordsToFind = [ { text: "AMOR", found: false }, { text: "PAIXAO", found: false }, { text: "CARINHO", found: false }, { text: "BEIJO", found: false }, { text: "ETERNO", found: false } ]; const ws_prizes = ["Baton Garoto 🍫", "Diamante Negro 💎", "Ouro Branco ✨", "Prestígio 🥥", "M&M's ®️🌈"]; const ws_gridSize = 12; let ws_grid = []; let ws_isSelecting = false; let ws_selectionPath = []; let ws_foundWordsCount = 0;
            function ws_generateRandomLetter() { const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; return alphabet[Math.floor(Math.random() * alphabet.length)]; }
            function ws_canPlaceWord(word, r, c, dr, dc) { for (let i = 0; i < word.length; i++) { const nr = r + i * dr; const nc = c + i * dc; if (nr < 0 || nr >= ws_gridSize || nc < 0 || nc >= ws_gridSize || (ws_grid[nr][nc] !== null && ws_grid[nr][nc] !== word[i])) return false; } return true; }
            function ws_placeWordInGrid(wordObj) { const word = wordObj.text; const directions = [ { dr: 0, dc: 1 }, { dr: 1, dc: 0 }, { dr: 1, dc: 1 }, { dr: 0, dc: -1 }, { dr: -1, dc: 0 }, { dr: -1, dc: -1 }, { dr: 1, dc: -1 }, { dr: -1, dc: 1 }]; let placed = false; let attempts = 0; while (!placed && attempts < 100) { const dir = directions[Math.floor(Math.random() * directions.length)]; const r = Math.floor(Math.random() * ws_gridSize); const c = Math.floor(Math.random() * ws_gridSize); if (ws_canPlaceWord(word, r, c, dir.dr, dir.dc)) { for (let i = 0; i < word.length; i++) { ws_grid[r + i * dir.dr][c + i * dir.dc] = word[i]; } placed = true; } attempts++; } return placed; }
            function ws_initializeGrid() { ws_grid = Array(ws_gridSize).fill(null).map(() => Array(ws_gridSize).fill(null)); ws_wordsToFind.forEach(w => w.found = false); ws_foundWordsCount = 0; [...ws_wordsToFind].sort(() => 0.5 - Math.random()).forEach(ws_placeWordInGrid); for (let r = 0; r < ws_gridSize; r++) for (let c = 0; c < ws_gridSize; c++) if (ws_grid[r][c] === null) ws_grid[r][c] = ws_generateRandomLetter(); }
            function ws_renderGrid() { ws_gridContainer.innerHTML = ''; ws_gridContainer.style.gridTemplateColumns = `repeat(${ws_gridSize}, 1fr)`; for (let r = 0; r < ws_gridSize; r++) for (let c = 0; c < ws_gridSize; c++) { const cell = document.createElement('div'); cell.classList.add('ws-cell'); cell.textContent = ws_grid[r][c]; cell.dataset.row = r; cell.dataset.col = c; cell.addEventListener('mousedown', (e) => ws_handleCellMouseDown(e, cell, r, c)); cell.addEventListener('mouseenter', (e) => ws_handleCellMouseEnter(e, cell, r, c)); ws_gridContainer.appendChild(cell); } document.addEventListener('mouseup', ws_handleCellMouseUp, true); }
            function ws_renderWordList() { ws_wordListElement.innerHTML = ''; ws_wordsToFind.forEach(w => { const li = document.createElement('li'); li.textContent = w.text; if (w.found) li.classList.add('found-in-list'); ws_wordListElement.appendChild(li); }); ws_totalWordsElement.textContent = ws_wordsToFind.length; ws_updateFoundCount(); }
            function ws_updateFoundCount() { ws_foundCountElement.textContent = ws_foundWordsCount; if (ws_foundWordsCount > 0 && ws_foundWordsCount <= ws_prizes.length) { ws_prizeWonElement.textContent = ws_prizes[ws_foundWordsCount - 1]; ws_prizeContainerElement.style.display = 'block'; } else if (ws_foundWordsCount === 0) { ws_prizeWonElement.textContent = "Continue procurando os doces sentimentos! 🥰"; ws_prizeContainerElement.style.display = 'block'; } if (ws_foundWordsCount === ws_wordsToFind.length) { ws_feedbackElement.textContent = "Parabéns! Você encontrou todas as palavras de amor!"; ws_prizeWonElement.textContent += " - Prêmio Máximo! 🏆"; }}
            function ws_handleCellMouseDown(event, cellElement, row, col) { event.preventDefault(); ws_isSelecting = true; ws_selectionPath = [{ element: cellElement, row: row, col: col, letter: ws_grid[row][col] }]; cellElement.classList.add('selected'); ws_feedbackElement.textContent = ""; }
            function ws_handleCellMouseEnter(event, cellElement, row, col) { if (!ws_isSelecting || ws_selectionPath.some(p => p.element === cellElement)) return; const lastPathCell = ws_selectionPath[ws_selectionPath.length - 1]; if (ws_selectionPath.length === 1) { const dr = Math.abs(row - lastPathCell.row); const dc = Math.abs(col - lastPathCell.col); if (!((dr <= 1 && dc <= 1) && (dr !== 0 || dc !== 0))) return; } else if (ws_selectionPath.length > 1) { const firstPathCell = ws_selectionPath[0]; const secondPathCell = ws_selectionPath[1]; const established_dr = secondPathCell.row - firstPathCell.row; const established_dc = secondPathCell.col - firstPathCell.col; const current_dr = row - lastPathCell.row; const current_dc = col - lastPathCell.col; if (current_dr !== established_dr || current_dc !== established_dc) return; } ws_selectionPath.push({ element: cellElement, row: row, col: col, letter: ws_grid[row][col] }); cellElement.classList.add('selected'); }
            function ws_handleCellMouseUp() { if (!ws_isSelecting || ws_selectionPath.length === 0) { ws_isSelecting = false; return; } ws_isSelecting = false; let selectedWordForward = ws_selectionPath.map(p => p.letter).join(''); let selectedWordBackward = [...ws_selectionPath].reverse().map(p => p.letter).join(''); let wordFoundThisTurn = false; for (const wordObj of ws_wordsToFind) { if (!wordObj.found && (wordObj.text === selectedWordForward || wordObj.text === selectedWordBackward)) { wordObj.found = true; wordFoundThisTurn = true; ws_foundWordsCount++; ws_selectionPath.forEach(p => p.element.classList.add('found')); break; } } if (wordFoundThisTurn) ws_feedbackElement.textContent = "Palavra encontrada! 😍"; else ws_feedbackElement.textContent = "Não é uma palavra da lista. Tente de novo! 🤔"; ws_selectionPath.forEach(p => p.element.classList.remove('selected')); ws_selectionPath = []; ws_renderWordList(); }
            function ws_resetWordSearchGame() { ws_initializeGrid(); ws_renderGrid(); ws_renderWordList(); ws_prizeContainerElement.style.display = 'none'; ws_prizeWonElement.textContent = ''; ws_feedbackElement.textContent = ""; }
            ws_resetButton.addEventListener('click', ws_resetWordSearchGame); ws_resetWordSearchGame();
        } else { console.error("Elementos do Caça Palavras não encontrados."); }
    } catch (e) { console.error("Erro no Caça Palavras:", e); }

    // --- LÓGICA PARA O QUEBRA-CABEÇA DO AMOR ---
    try {
        const puzzleBoardContainer = document.getElementById('puzzle-board-container');
        const startPuzzleButton = document.getElementById('start-puzzle-button');
        const puzzleMessage = document.getElementById('puzzle-message');
        
        if (puzzleBoardContainer && startPuzzleButton && puzzleMessage) {
            const PUZZLE_IMAGE_SRC = 'nos.png'; // Imagem que você fornecerá
            const PUZZLE_ROWS = 3;
            const PUZZLE_COLS = 3;
            let puzzlePieces = [];
            let puzzleImageWidth, puzzleImageHeight;
            let pieceWidth, pieceHeight;
            let draggedPiece = null;

            const puzzleImage = new Image();
            puzzleImage.onload = () => {
                puzzleImageWidth = puzzleImage.width;
                puzzleImageHeight = puzzleImage.height;
                // Ajusta o tamanho do board para manter a proporção da imagem, se necessário
                // Para este exemplo, vamos fixar o tamanho do board e ajustar as peças.
                // O CSS já define o board como 300x300.
                // As peças terão background-size: 300px 300px;
                
                pieceWidth = puzzleBoardContainer.clientWidth / PUZZLE_COLS;
                pieceHeight = puzzleBoardContainer.clientHeight / PUZZLE_ROWS;

                puzzleBoardContainer.style.gridTemplateColumns = `repeat(${PUZZLE_COLS}, 1fr)`;
                createPuzzlePieces();
                puzzleMessage.textContent = "Clique em 'Embaralhar e Começar'!";
            };
            puzzleImage.onerror = () => {
                puzzleMessage.textContent = "Erro ao carregar a imagem do quebra-cabeça (nos.png não encontrada?).";
                puzzleMessage.style.color = "red";
            }
            puzzleImage.src = PUZZLE_IMAGE_SRC;

            function createPuzzlePieces() {
                puzzlePieces = [];
                puzzleBoardContainer.innerHTML = ''; // Limpa o tabuleiro
                for (let i = 0; i < PUZZLE_ROWS * PUZZLE_COLS; i++) {
                    const piece = document.createElement('div');
                    piece.classList.add('puzzle-piece');
                    piece.style.width = `${pieceWidth}px`;
                    piece.style.height = `${pieceHeight}px`;
                    piece.style.backgroundImage = `url(${PUZZLE_IMAGE_SRC})`;
                    
                    const col = i % PUZZLE_COLS;
                    const row = Math.floor(i / PUZZLE_COLS);
                    
                    piece.style.backgroundPosition = `-${col * pieceWidth}px -${row * pieceHeight}px`;
                    piece.dataset.correctIndex = i; // Posição correta original
                    piece.dataset.currentIndex = i; // Posição atual no tabuleiro (será mudada ao embaralhar)
                    piece.draggable = true;

                    piece.addEventListener('dragstart', p_handleDragStart);
                    piece.addEventListener('dragover', p_handleDragOver);
                    piece.addEventListener('drop', p_handleDrop);
                    piece.addEventListener('dragend', p_handleDragEnd);
                    
                    puzzlePieces.push(piece);
                    puzzleBoardContainer.appendChild(piece);
                }
            }

            function shuffleAndDisplayPieces() {
                // Simples shuffle de array
                for (let i = puzzlePieces.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [puzzlePieces[i], puzzlePieces[j]] = [puzzlePieces[j], puzzlePieces[i]];
                }

                // Re-renderiza no DOM na ordem embaralhada
                puzzleBoardContainer.innerHTML = '';
                puzzlePieces.forEach((piece, index) => {
                    piece.dataset.currentIndex = index; // Atualiza o índice atual após embaralhar
                    puzzleBoardContainer.appendChild(piece);
                });
                puzzleMessage.textContent = "Quebra-cabeça embaralhado! Boa sorte!";
            }

            function p_handleDragStart(e) {
                draggedPiece = this;
                this.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.dataset.currentIndex); // Passa o índice da peça
            }

            function p_handleDragOver(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                this.classList.add('over');
            }
            
            function p_handleDrop(e) {
                e.preventDefault();
                this.classList.remove('over');
                if (draggedPiece === this) return; // Não soltar sobre si mesmo

                const draggedIndex = parseInt(draggedPiece.dataset.currentIndex);
                const targetIndex = parseInt(this.dataset.currentIndex);

                // Troca as peças no array `puzzlePieces`
                const temp = puzzlePieces[draggedIndex];
                puzzlePieces[draggedIndex] = puzzlePieces[targetIndex];
                puzzlePieces[targetIndex] = temp;

                // Atualiza os data-currentIndex das peças trocadas
                puzzlePieces[draggedIndex].dataset.currentIndex = draggedIndex;
                puzzlePieces[targetIndex].dataset.currentIndex = targetIndex;
                
                // Re-renderiza o tabuleiro com a nova ordem das peças
                puzzleBoardContainer.innerHTML = '';
                puzzlePieces.forEach(p => puzzleBoardContainer.appendChild(p));
                
                checkPuzzleCompletion();
            }

            function p_handleDragEnd() {
                this.classList.remove('dragging');
                // Limpa a classe 'over' de todas as peças (caso o drop não ocorra sobre uma peça válida)
                puzzlePieces.forEach(p => p.classList.remove('over'));
                draggedPiece = null;
            }
            
            function checkPuzzleCompletion() {
                let solved = true;
                for (let i = 0; i < puzzlePieces.length; i++) {
                    // Verifica se a peça na posição 'i' do tabuleiro é a peça que deveria estar lá
                    if (parseInt(puzzlePieces[i].dataset.correctIndex) !== i) {
                         // Se a peça que está no slot 'i' não tem o correctIndex 'i', não está resolvido
                         // Esta lógica está um pouco confusa. A forma mais simples é verificar se o DOM está na ordem correta.
                         // Ou, se cada peça está no seu slot de índice correto.
                         // A lógica de `currentIndex` vs `correctIndex` na peça é melhor.
                         // O puzzle está resolvido se `piece.dataset.currentIndex == piece.dataset.correctIndex` para todas as peças
                         // E elas estiverem na ordem correta no DOM.
                         // Com a troca de DOM, a verificação é se a peça no slot `i` é a peça `i` original.
                        solved = false;
                        break;
                    }
                }
                // Simplificação: se a ordem no array `puzzlePieces` (que reflete o DOM)
                // tem cada peça com `dataset.correctIndex` igual ao seu índice no array, está resolvido.
                solved = true; // Assume solved
                puzzlePieces.forEach((piece, index) => {
                    if (parseInt(piece.dataset.correctIndex) !== index) {
                        solved = false;
                    }
                });


                if (solved) {
                    puzzleMessage.textContent = "🎉 Parabéns! Quebra-cabeça resolvido com amor! 🎉";
                    puzzleMessage.style.color = "#4CAF50"; // Verde para sucesso
                    // Opcional: Desabilitar drag and drop
                    puzzlePieces.forEach(p => p.draggable = false);
                } else {
                    puzzleMessage.textContent = "Continue tentando montar!";
                }
            }

            startPuzzleButton.addEventListener('click', () => {
                if (!puzzleImage.complete || puzzleImage.naturalHeight === 0) {
                    puzzleMessage.textContent = "A imagem ainda está carregando ou não foi encontrada. Tente novamente em instantes.";
                    puzzleImage.src = PUZZLE_IMAGE_SRC; // Tenta recarregar se falhou
                    return;
                }
                // Recria as peças para o caso de as dimensões não estarem prontas antes
                pieceWidth = puzzleBoardContainer.clientWidth / PUZZLE_COLS;
                pieceHeight = puzzleBoardContainer.clientHeight / PUZZLE_ROWS;
                createPuzzlePieces(); // Garante que as peças são recriadas com os tamanhos corretos
                shuffleAndDisplayPieces();
                puzzlePieces.forEach(p => p.draggable = true); // Habilita drag ao iniciar/reiniciar
                puzzleMessage.style.color = ""; // Reseta cor da mensagem
            });

        } else { console.error("Elementos do Quebra-Cabeça não encontrados."); }
    } catch (e) { console.error("Erro no Quebra-Cabeça:", e); }

    // --- NOVO JOGO: LABORATÓRIO DO AMOR (BALANCEAMENTO) ---
    try {
        const labEquationDisplay = document.getElementById('equation-display');
        const labCheckButton = document.getElementById('check-equation-button');
        const labNextButton = document.getElementById('next-equation-button');
        const labMessage = document.getElementById('lab-message');
        const labStory = document.getElementById('equation-story');

        if (labEquationDisplay && labCheckButton && labNextButton && labMessage && labStory) {
            const loveEquations = [
                {
                    reactants: [{ name: "Mauro", symbol: "M", coeff: 1 }, { name: "Lays", symbol: "L", coeff: 1 }],
                    products: [{ name: "UniãoPerfeita", symbol: "ML", coeff: 1 }],
                    story: "Quando Mauro e Lays se unem, a magia acontece, formando uma União Perfeita e indivisível!"
                },
                {
                    reactants: [{ name: "Café ☕", symbol: "Cf", coeff: 1 }, { name: "Beijos 😘", symbol: "Bj", coeff: 2 }],
                    products: [{ name: "ManhãRadiante", symbol: "CfBj₂", coeff: 1 }],
                    story: "Um bom café e dois beijos de bom dia: a fórmula para uma Manhã Radiante e cheia de energia!"
                },
                {
                    reactants: [{ name: "Filme 🎬", symbol: "Fm", coeff: 1 }, { name: "Pipoca 🍿", symbol: "Pp", coeff: 1 }, { name: "Cobertor Quentinho", symbol: "Cb", coeff: 1 }],
                    products: [{ name: "NoiteAconchegante", symbol: "FmPpCb", coeff: 1 }],
                    story: "A combinação ideal de filme, pipoca e um cobertor resulta em uma Noite Aconchegante e cheia de amor."
                },
                {
                    reactants: [{ name: "Abraços 🤗", symbol: "Ab", coeff: 2 }, { name: "Sorrisos 😊", symbol: "So", coeff: 2 }],
                    products: [{ name: "Felicidade²", symbol: "Ab₂So₂", coeff: 1 }],
                    story: "Dois abraços apertados e dois sorrisos sinceros multiplicam a felicidade ao quadrado!"
                }
            ];
            let currentEquationIndex = 0;
            let currentEquation;

            function displayEquation(eq) {
                currentEquation = eq;
                labEquationDisplay.innerHTML = '';
                labStory.textContent = eq.story;
                labMessage.textContent = 'Insira os coeficientes para balancear a fórmula do amor!';
                labNextButton.style.display = 'none';
                labCheckButton.style.display = 'inline-block';

                eq.reactants.forEach((r, index) => {
                    if (index > 0) labEquationDisplay.innerHTML += ' <span class="operator">+</span> ';
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.min = '1';
                    input.value = '1';
                    input.classList.add('coeff-input');
                    input.dataset.type = 'reactant';
                    input.dataset.index = index;
                    labEquationDisplay.appendChild(input);
                    const nameSpan = document.createElement('span');
                    nameSpan.classList.add('molecule-name');
                    nameSpan.textContent = ` ${r.name} (${r.symbol})`;
                    labEquationDisplay.appendChild(nameSpan);
                });

                labEquationDisplay.innerHTML += ' <span class="arrow">→</span> ';

                eq.products.forEach((p, index) => {
                    if (index > 0) labEquationDisplay.innerHTML += ' <span class="operator">+</span> ';
                     const input = document.createElement('input');
                    input.type = 'number';
                    input.min = '1';
                    input.value = '1';
                    input.classList.add('coeff-input');
                    input.dataset.type = 'product';
                    input.dataset.index = index;
                    labEquationDisplay.appendChild(input);
                    const nameSpan = document.createElement('span');
                    nameSpan.classList.add('molecule-name');
                    nameSpan.textContent = ` ${p.name} (${p.symbol})`;
                    labEquationDisplay.appendChild(nameSpan);
                });
            }

            function checkBalance() {
                if (!currentEquation) return;
                let userReactantCoeffs = [];
                let userProductCoeffs = [];
                const inputs = labEquationDisplay.querySelectorAll('.coeff-input');
                
                inputs.forEach(input => {
                    if (input.dataset.type === 'reactant') {
                        userReactantCoeffs[parseInt(input.dataset.index)] = parseInt(input.value) || 0;
                    } else {
                        userProductCoeffs[parseInt(input.dataset.index)] = parseInt(input.value) || 0;
                    }
                });

                let isCorrect = true;
                for (let i = 0; i < currentEquation.reactants.length; i++) {
                    if (userReactantCoeffs[i] !== currentEquation.reactants[i].coeff) {
                        isCorrect = false; break;
                    }
                }
                if (isCorrect) {
                    for (let i = 0; i < currentEquation.products.length; i++) {
                        if (userProductCoeffs[i] !== currentEquation.products[i].coeff) {
                            isCorrect = false; break;
                        }
                    }
                }

                if (isCorrect) {
                    labMessage.textContent = "🎉 Perfeitamente Balanceado! Vocês têm química de sobra! ❤️";
                    labMessage.style.color = 'green';
                    labNextButton.style.display = 'inline-block';
                    labCheckButton.style.display = 'none';
                } else {
                    labMessage.textContent = "Hmm, essa fórmula parece um pouco instável... Tente de novo! 🤔";
                    labMessage.style.color = 'red';
                }
            }
            
            labCheckButton.addEventListener('click', checkBalance);
            labNextButton.addEventListener('click', () => {
                currentEquationIndex = (currentEquationIndex + 1) % loveEquations.length;
                displayEquation(loveEquations[currentEquationIndex]);
                labMessage.style.color = ''; // Reset color
            });

            displayEquation(loveEquations[currentEquationIndex]); // Load first equation

        } else { console.error("Elementos do Laboratório do Amor não encontrados."); }
    } catch(e) { console.error("Erro no Laboratório do Amor:", e); }

    // --- Gráficos (Love Journey & Perfect Heart) ---
    try { /* ... (Código dos Gráficos como na resposta anterior) ... */
        const currentDate = new Date(); const timeDiff = currentDate.getTime() - relationshipStartDate.getTime(); let daysPassedSinceStart = Math.max(1, Math.ceil(timeDiff / (1000 * 60 * 60 * 24))); const loveJourneyDesc = document.getElementById('loveJourneyDescription'); if (loveJourneyDesc) { loveJourneyDesc.textContent = `Gráfico do crescimento do nosso amor ao longo de ${daysPassedSinceStart} dia(s) incríveis!`; } function generateLogGrowthData(totalDays) { const labels = []; const dataLays = []; const dataMauro = []; const A_Lays = 20, B_Lays = 0.15, C_Lays = 15; const A_Mauro = 22, B_Mauro = 0.12, C_Mauro = 12; for (let day = 1; day <= totalDays; day++) { labels.push("Dia " + day); dataLays.push(A_Lays * Math.log(B_Lays * day + 1) + C_Lays + Math.random() * 2.5); dataMauro.push(A_Mauro * Math.log(B_Mauro * day + 1) + C_Mauro + Math.random() * 2.5); } return { labels, dataLays, dataMauro }; }
        const { labels, dataLays, dataMauro } = generateLogGrowthData(daysPassedSinceStart); const heartChartCanvas = document.getElementById('heartChart'); if (heartChartCanvas) new Chart(heartChartCanvas.getContext('2d'), { type: 'line', data: { labels, datasets: [ { label: 'Lays 💖', data: dataLays, borderColor: '#ff69b4', backgroundColor: 'rgba(255,105,180,0.2)', fill: true, tension: 0.4 }, { label: 'Mauro 💘', data: dataMauro, borderColor: '#db2777', backgroundColor: 'rgba(219,39,119,0.2)', fill: true, tension: 0.4 } ]}, options: { responsive: true, plugins: { title: { display: true, text: 'O Crescimento Infinito do Nosso Amor ❤️', font: { size: 22 }, color: '#d63384' }, legend: { labels: { font: { size: 14 }}}}, scales: { y: { beginAtZero: false, title: { display: true, text: 'Intensidade do Amor (Crescimento Infinito)' }}, x: { title: { display: true, text: 'Dias de Amor Eterno' }}} , animation: { duration: 1500, easing: 'easeInOutQuint' } } });
        function generatePerfectHeartPlotData(steps) { const dataPoints = []; for (let i = 0; i <= steps; i++) { const t = (Math.PI * 2 * i) / steps; const x = 16 * Math.pow(Math.sin(t), 3); const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t); dataPoints.push({ x: x, y: y }); } return dataPoints; } const perfectHeartPoints = generatePerfectHeartPlotData(100); const perfectHeartCanvas = document.getElementById('perfectHeartShapeChart'); if (perfectHeartCanvas) new Chart(perfectHeartCanvas.getContext('2d'), { type: 'line', data: { datasets: [{ label: 'Coração Perfeito', data: perfectHeartPoints, borderColor: '#d63384', backgroundColor: 'rgba(214, 51, 132, 0.3)', fill: true, tension: 0, pointRadius: 0, borderWidth: 3 }] }, options: { responsive: true, maintainAspectRatio: true, plugins: { title: { display: true, text: 'Símbolo do Nosso Amor Eterno 💘', font: { size: 22, family: 'Segoe UI'}, color: '#d63384'}, legend: {display: false}}, scales: { x: {type: 'linear', display: false}, y: {type: 'linear', display: false}} , animation: { duration: 2500, easing: 'easeOutCubic'} } });
    } catch (e) { console.error("Erro nos gráficos:", e); }

    // --- LÓGICA PARA O QUIZ DO CASAL ---
    try { /* ... (Código do Quiz como na resposta anterior) ... */
        const quizData = [ { question: "Onde foi nosso primeiro beijo?", options: ["Na pracinha da cidade", "No cinema local", "No laguinho da UFPE", "Na festa de Ana Maria"], correctAnswer: 2 }, { question: "Qual a data do nosso aniversário de namoro?", options: ["05 de Março", "15 de Abril", "05 de Junho", "20 de Fevereiro"], correctAnswer: 0 }, { question: "Onde nos conhecemos?", options: ["Na faculdade (UFPE)", "No trabalho", "Online, num app", "Numa festa de amigos"], correctAnswer: 0 }, { question: "Onde foi realizado o pedido de namoro?", options: ["Em um jantar romântico especial", "Na praia ao pôr do sol", "Na cozinha da casa de Lays", "Durante um piquenique no parque"], correctAnswer: 2 }, { question: "Qual local mais frequentamos juntos?", options: ["Parque da cidade aos domingos", "Sorveteria Delícia Tropical", "Cinema do Shopping X", "Emflor Cafeteria"], correctAnswer: 3 }, { question: "Qual foi nosso primeiro date (encontro)?", options: ["Jantar e cinema", "Jantar seguido de passeio de Catamarã", "Piquenique no parque e sorvete", "Show de rock alternativo e barzinho"], correctAnswer: 1 }, { question: "Qual primeira refeição que fizemos após o pedido de namoro?", options: ["Pizza e refrigerante", "Sushi e saquê", "Batata doce e bife", "Lasanha caseira e vinho"], correctAnswer: 2 }, { question: "Qual primeiro presente Lays recebeu do namorado?", options: ["Um buquê de rosas vermelhas", "Uma caixa de chocolates finos importados", "Uma cesta em comemoração ao Dia das Mulheres", "Um livro de romance famoso"], correctAnswer: 2 }, { question: "Quantas vezes Lays recebeu flores do namorado?", options: ["Apenas uma vez, no início", "Duas vezes, em datas especiais", "Três vezes contadas", "Mais de 3 vezes, ele é um romântico!"], correctAnswer: 3 }, { question: "O que Lays recebeu de presente de Páscoa?", options: [ "Um ovo de Páscoa gigante da marca favorita dela", "Uma cesta com chocolates, 3 mini ovos de colher, uma bag e um boné", "Apenas uma caixa com chocolates variados e uma cartinha", "Um coelhinho de pelúcia fofo e alguns bombons" ], correctAnswer: 1 } ];
        let currentQuestionIndex = 0; let scores = { Lays: 0, Mauro: 0 }; let currentPlayer = "Lays"; let quizFinished = false; const questionElement = document.getElementById('quizQuestion'); const optionsElement = document.getElementById('quizOptions'); const nextButton = document.getElementById('nextQuizButton'); const scoreElement = document.getElementById('quizScore'); const thermometerBar = document.getElementById('loveThermometerBar'); const playerIndicator = document.getElementById('playerIndicator');
        if (questionElement && optionsElement && nextButton && scoreElement && thermometerBar && playerIndicator) { function loadQuizQuestion() { if (quizFinished) return; let actualQuestionIndexForPlayer = (currentPlayer === "Lays") ? currentQuestionIndex : currentQuestionIndex - quizData.length; playerIndicator.textContent = `Vez de: ${currentPlayer} responder!`; const questionToShowIndex = actualQuestionIndexForPlayer; if (questionToShowIndex >= quizData.length) { showQuizResults(); return; } const currentQ = quizData[questionToShowIndex]; questionElement.textContent = `Pergunta ${questionToShowIndex + 1}: ${currentQ.question}`; optionsElement.innerHTML = ""; currentQ.options.forEach((option, index) => { const li = document.createElement('label'); li.innerHTML = `<input type="radio" name="quizOption" value="${index}"> ${option}`; optionsElement.appendChild(li); }); nextButton.textContent = "Confirmar Resposta"; nextButton.disabled = false; } function handleQuizSubmission() { if (quizFinished) { currentQuestionIndex = 0; scores = { Lays: 0, Mauro: 0 }; currentPlayer = "Lays"; quizFinished = false; scoreElement.textContent = ""; updateLoveThermometer(); loadQuizQuestion(); return; } const selectedOption = document.querySelector('input[name="quizOption"]:checked'); if (!selectedOption) { alert("Por favor, selecione uma opção!"); return; } const questionIndexOfPlayer = (currentPlayer === "Lays") ? currentQuestionIndex : currentQuestionIndex - quizData.length; if (parseInt(selectedOption.value) === quizData[questionIndexOfPlayer].correctAnswer) { scores[currentPlayer]++; } currentQuestionIndex++; if (currentPlayer === "Lays" && (currentQuestionIndex >= quizData.length)) { currentPlayer = "Mauro"; alert("Lays completou! Agora é a vez de Mauro."); loadQuizQuestion(); } else if (currentPlayer === "Mauro" && (currentQuestionIndex - quizData.length >= quizData.length)) { showQuizResults(); } else { loadQuizQuestion(); } updateLoveThermometer(); } function showQuizResults() { quizFinished = true; questionElement.textContent = "Quiz Finalizado!"; optionsElement.innerHTML = ""; playerIndicator.textContent = "Resultado Final:"; scoreElement.innerHTML = `Pontuação:<br>Lays: ${scores.Lays} de ${quizData.length} <br>Mauro: ${scores.Mauro} de ${quizData.length}`; nextButton.textContent = "Jogar Novamente"; nextButton.disabled = false; updateLoveThermometer(); } function updateLoveThermometer() { const totalPossibleScore = quizData.length * 2; const combinedScore = scores.Lays + scores.Mauro; const percentage = totalPossibleScore > 0 ? (combinedScore / totalPossibleScore) * 100 : 0; thermometerBar.style.width = `${percentage}%`; thermometerBar.textContent = `${Math.round(percentage)}% Sintonia`; } nextButton.addEventListener('click', handleQuizSubmission); loadQuizQuestion(); } else { console.error("Elementos do Quiz não encontrados."); }
    } catch (e) { console.error("Erro no Quiz:", e); }

    // --- LÓGICA PARA ROLETA DO AMOR ---
    try { /* ... (Código da Roleta como na resposta anterior, com a correção do cálculo do prêmio) ... */
        const rouletteCanvasEl = document.getElementById('rouletteCanvas'); const spinButtonEl = document.getElementById('spinRouletteButton'); const rouletteResultElementEl = document.getElementById('rouletteResult');
        if (rouletteCanvasEl && spinButtonEl && rouletteResultElementEl) {
            const rouletteCtxEl = rouletteCanvasEl.getContext('2d'); const roulettePrizes = [ "Vale um abraço apertado 🤗", "Vale um beijo demorado 😘", "Massagem relaxante 💆‍♀️💆‍♂️", "Escolher o filme de hoje 🎬", "Jantar especial feito por mim 🍳", "Um elogio sincero ✨", "Café na cama surpresa ☕🥐", "Noite de jogos divertidos 🎲", "Passeio romântico 🌳", "Ouvir sua música favorita juntos 🎶", "Um desejo realizado (simples!) 🌟", "Escrever um bilhetinho de amor 💌" ]; const numSegmentsRoulette = roulettePrizes.length; const anglePerSegmentRoulette = (2 * Math.PI) / numSegmentsRoulette; const colorsRoulette = ["#FFC0CB", "#FFB6C1", "#FF69B4", "#DB7093", "#C71585", "#E6E6FA", "#D8BFD8", "#DDA0DD", "#DA70D6", "#BA55D3", "#FFC0CB", "#FFB6C1"]; let currentAngleRoulette = 0; let spinTimeoutRoulette = null; let isSpinningRoulette = false;
            function drawRouletteSegment(index, text, startAngle, endAngle) { rouletteCtxEl.beginPath(); rouletteCtxEl.fillStyle = colorsRoulette[index % colorsRoulette.length]; rouletteCtxEl.moveTo(rouletteCanvasEl.width / 2, rouletteCanvasEl.height / 2); rouletteCtxEl.arc(rouletteCanvasEl.width / 2, rouletteCanvasEl.height / 2, rouletteCanvasEl.width / 2 - 10, startAngle, endAngle); rouletteCtxEl.closePath(); rouletteCtxEl.fill(); rouletteCtxEl.stroke(); rouletteCtxEl.save(); rouletteCtxEl.fillStyle = "#4B0082"; rouletteCtxEl.font = "bold 13px Segoe UI"; rouletteCtxEl.translate(rouletteCanvasEl.width / 2, rouletteCanvasEl.height / 2); rouletteCtxEl.rotate(startAngle + anglePerSegmentRoulette / 2); rouletteCtxEl.textAlign = "right"; rouletteCtxEl.fillText(text, rouletteCanvasEl.width / 2 - 25, 7); rouletteCtxEl.restore(); }
            function drawRoulette() { rouletteCtxEl.clearRect(0, 0, rouletteCanvasEl.width, rouletteCanvasEl.height); rouletteCtxEl.strokeStyle = '#d63384'; rouletteCtxEl.lineWidth = 2; for (let i = 0; i < numSegmentsRoulette; i++) { drawRouletteSegment(i, roulettePrizes[i], currentAngleRoulette + i * anglePerSegmentRoulette, currentAngleRoulette + (i + 1) * anglePerSegmentRoulette); } rouletteCtxEl.fillStyle = '#e6005c'; rouletteCtxEl.beginPath(); rouletteCtxEl.moveTo(rouletteCanvasEl.width / 2 - 10, 7); rouletteCtxEl.lineTo(rouletteCanvasEl.width / 2 + 10, 7); rouletteCtxEl.lineTo(rouletteCanvasEl.width / 2, 38); rouletteCtxEl.closePath(); rouletteCtxEl.fill(); }
            function spinRoulette() { if (isSpinningRoulette) return; isSpinningRoulette = true; spinButtonEl.disabled = true; rouletteResultElementEl.textContent = "Girando..."; const targetRotation = (Math.random() * 10 + 15) * Math.PI * 2; const spinDuration = Math.random() * 3000 + 5000; let startTimestamp = null; const initialAngle = currentAngleRoulette; function rotate(timestamp) { if (!startTimestamp) startTimestamp = timestamp; const progress = timestamp - startTimestamp; if (progress < spinDuration) { const easedProgress = 1 - Math.pow(1 - (progress / spinDuration), 4); currentAngleRoulette = initialAngle + (targetRotation * easedProgress); drawRoulette(); spinTimeoutRoulette = requestAnimationFrame(rotate); } else { currentAngleRoulette = initialAngle + targetRotation; drawRoulette(); const finalAngleOfSeg0 = currentAngleRoulette % (2 * Math.PI); const pointerAngle = 1.5 * Math.PI; let offsetFromSeg0ToPointer = (pointerAngle - finalAngleOfSeg0); offsetFromSeg0ToPointer = (offsetFromSeg0ToPointer % (2 * Math.PI) + (2 * Math.PI)) % (2 * Math.PI); const winningSegmentIndex = Math.floor(offsetFromSeg0ToPointer / anglePerSegmentRoulette); if (roulettePrizes[winningSegmentIndex]) { rouletteResultElementEl.textContent = `🎉 ${roulettePrizes[winningSegmentIndex]} 🎉`; } else { rouletteResultElementEl.textContent = "Tente de novo! 🤔"; console.error("Índice do segmento vencedor inválido:", winningSegmentIndex); } isSpinningRoulette = false; spinButtonEl.disabled = false; } } spinTimeoutRoulette = requestAnimationFrame(rotate); }
            spinButtonEl.addEventListener('click', spinRoulette); drawRoulette();
        } else { console.error("Elementos da Roleta não encontrados no DOM."); }
    } catch (e) { console.error("Erro na Roleta:", e); }

});
</script>
</body>
</html>